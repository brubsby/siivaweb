<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SiIvaGunner Rip Graph (WebGL/PixiJS)</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.3.2/pixi.min.js"></script>
    <style>
        body {
            margin: 0;
            background-color: #1e1e1e;
            color: #ccc;
            font-family: sans-serif;
            overflow: hidden;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        .controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(30, 30, 30, 0.9);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #444;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            max-width: 300px;
        }
        .control-group {
            display: flex;
            flex-direction: column;
        }
        .control-group label {
            margin-bottom: 5px;
            font-size: 12px;
            color: #aaa;
        }
        .control-group input[type="range"] {
            width: 100%;
        }
        .help-text {
            font-size: 11px;
            color: #aaa;
            margin-bottom: 12px;
            line-height: 1.4;
            border-bottom: 1px solid #444;
            padding-bottom: 8px;
        }
        .help-text strong {
            color: #69b3a2;
        }
        .input-group {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
            border-bottom: 1px solid #555;
            padding-bottom: 10px;
        }
        .input-group input[type="text"] {
            background: #333;
            border: 1px solid #555;
            color: #eee;
            padding: 5px;
            border-radius: 4px;
            flex-grow: 1;
        }
        .input-group button {
            background: #69b3a2;
            border: none;
            color: #fff;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
        }
        .input-group button:hover {
            background: #5aa090;
        }
        .legend {
            display: flex;
            gap: 10px;
            font-size: 11px;
            margin-bottom: 5px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .legend-color {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }
        /* HTML Tooltip for better text rendering/handling than Pixi text */
        #tooltip {
            position: absolute;
            background: rgba(30, 30, 30, 0.9);
            color: #eee;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            display: none;
            z-index: 200;
            border: 1px solid #555;
            box-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body>
    <div id="tooltip"></div>

    <div class="controls">
        <div class="help-text">
            <strong>Left-click</strong> node to fetch connections.<br>
            <strong>Right-click</strong> node to prune.<br>
            <strong>Drag</strong> background to pan, wheel to zoom.<br>
            <span id="nodeCount" style="color: #fff;">Nodes: 0</span>
        </div>
        
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: #4a90e2;"></div>
                <span>Rip (Page)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #ff9f43;"></div>
                <span>Category</span>
            </div>
        </div>

        <div class="input-group">
            <input type="text" id="pageInput" placeholder="Rip Title (e.g. Athletic Theme)" value="">
            <button id="addPageBtn">Add Rip</button>
        </div>
        <div class="input-group">
            <input type="text" id="catInput" placeholder="Category (e.g. Rips featuring Mario)" value="">
            <button id="addCatBtn">Add Cat</button>
        </div>
        
        <div class="control-group">
            <label for="centerForce">Center Force: <span id="centerForceVal">0.01</span></label>
            <input type="range" id="centerForce" min="0" max="0.2" step="0.001" value="0.01">
        </div>
        <div class="control-group">
            <label for="repelForce">Repel Force: <span id="repelForceVal">100</span></label>
            <input type="range" id="repelForce" min="0" max="1000" value="100">
        </div>
        <div class="control-group">
            <label for="linkForce">Link Force: <span id="linkForceVal">0.05</span></label>
            <input type="range" id="linkForce" min="0" max="1" step="0.05" value="0.05">
        </div>
        <div class="control-group">
            <label for="linkDistance">Link Distance: <span id="linkDistanceVal">25</span></label>
            <input type="range" id="linkDistance" min="10" max="300" value="25">
        </div>
    </div>

    <script>
        // --- Configuration ---
        const NODE_RADIUS = 10;
        const INITIAL_RIP = "Athletic Theme (PAL Version) - Super Mario World";
        const API_BASE = "https://siivagunner.wiki/w/api.php";
        
        // --- State ---
        let nodes = [];
        let links = [];
        let linkDistanceBase = 25;
        let tooltip = document.getElementById('tooltip');
        let abortExpansion = false;

        // --- PixiJS Setup ---
        const app = new PIXI.Application({
            width: window.innerWidth,
            height: window.innerHeight,
            antialias: true,
            backgroundColor: 0x1e1e1e,
            resolution: window.devicePixelRatio || 1,
            autoDensity: true,
        });
        document.body.appendChild(app.view);

        // Container for the graph (moves with zoom)
        const viewport = new PIXI.Container();
        app.stage.addChild(viewport);

        // Prevent default context menu on canvas
        app.view.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });
        
        // Layers
        const linkGraphics = new PIXI.Graphics();
        const nodeContainer = new PIXI.Container();
        viewport.addChild(linkGraphics);
        viewport.addChild(nodeContainer);

        // Textures (Generated once for performance)
        function createCircleTexture(color, radius) {
            const gr = new PIXI.Graphics();
            gr.beginFill(color);
            gr.lineStyle(1.5, 0xffffff);
            gr.drawCircle(0, 0, radius);
            gr.endFill();
            return app.renderer.generateTexture(gr);
        }
        
        const ripTexture = createCircleTexture(0x4a90e2, NODE_RADIUS);
        const catTexture = createCircleTexture(0xff9f43, NODE_RADIUS);
        const ripTextureVibrate = createCircleTexture(0x4a90e2, NODE_RADIUS + 1); // Slight larger for effect
        const catTextureVibrate = createCircleTexture(0xff9f43, NODE_RADIUS + 1);

        // Map to keep track of sprites {nodeId: Sprite}
        const nodeSprites = new Map();

        // --- D3 Simulation ---
        const simulation = d3.forceSimulation(nodes)
            .force("link", d3.forceLink(links).id(d => d.id).distance(getLinkDistance).strength(0.05))
            .force("charge", d3.forceManyBody().strength(-100))
            .force("center", d3.forceCenter(window.innerWidth / 2, window.innerHeight / 2))
            .force("x", d3.forceX(window.innerWidth / 2).strength(0.01))
            .force("y", d3.forceY(window.innerHeight / 2).strength(0.01));

        function getLinkDistance(d) {
            const source = d.source;
            const target = d.target;
            let dist = linkDistanceBase;
            if (source.type === 'category' && target.type === 'category') dist *= 2.0;
            else if (source.type === 'category' || target.type === 'category') dist *= 1.2;
            else dist *= 0.8;
            
            const combinedDegree = (source.degree || 0) + (target.degree || 0);
            if (combinedDegree > 5) dist += Math.min(combinedDegree * 2, 100);
            return dist;
        }

        // --- Render Loop ---
        app.ticker.add(() => {
            const now = Date.now();

            // 1. Update Node Sprites positions
            simulation.tick(); // Manually tick D3? Or let D3 internal timer run?
            // Actually D3 has its own timer. If we use simulation.on("tick"), it runs independently.
            // But syncing with Pixi ticker is smoother. We'll disable D3 internal timer and call tick manually here.
        });
        
        simulation.stop(); // Stop internal timer, we drive it with Pixi

        app.ticker.add((delta) => {
            // Run Physics
            simulation.tick(); 
            const now = Date.now();

            // Draw Links
            linkGraphics.clear();
            linkGraphics.lineStyle(1, 0x999999, 0.6);

            links.forEach(l => {
                let sx = l.source.x, sy = l.source.y;
                let tx = l.target.x, ty = l.target.y;

                // Jitter logic
                if (l.source.vibrationStart) {
                    const e = now - l.source.vibrationStart;
                    const i = Math.min(e * 0.02, 5);
                    sx += (Math.random() - 0.5) * i;
                    sy += (Math.random() - 0.5) * i;
                }
                if (l.target.vibrationStart) {
                    const e = now - l.target.vibrationStart;
                    const i = Math.min(e * 0.02, 5);
                    tx += (Math.random() - 0.5) * i;
                    ty += (Math.random() - 0.5) * i;
                }

                linkGraphics.moveTo(sx, sy);
                linkGraphics.lineTo(tx, ty);
            });

            // Update Nodes
            nodes.forEach(n => {
                let sprite = nodeSprites.get(n.id);
                
                // Create sprite if missing (should be handled in sync logic, but safety check)
                if (!sprite) return; 

                let dx = 0, dy = 0;
                
                // Vibration Logic & Visuals
                if (n.vibrationStart) {
                    const elapsed = now - n.vibrationStart;
                    const intensity = Math.min(elapsed * 0.02, 5);
                    dx = (Math.random() - 0.5) * intensity;
                    dy = (Math.random() - 0.5) * intensity;
                    
                    // Change texture/tint for loading effect
                    sprite.tint = 0xffcc00;
                    sprite.scale.set(1.1);
                    sprite.alpha = 1.0;
                } else {
                    sprite.tint = 0xffffff;
                    sprite.scale.set(1.0);
                    sprite.alpha = n.visited ? 1.0 : 0.5;
                }

                sprite.x = n.x + dx;
                sprite.y = n.y + dy;
            });
        });

        // --- Popup Logic ---
        let wikiWindow = null;
        let youtubeWindow = null;

        async function showPage(node) {
            const title = node.id; // Use node.id as the page title
            // 1. Open Wiki Page
            const wikiUrl = "https://siivagunner.wiki/wiki/" + encodeURIComponent(title);
            if (wikiWindow && !wikiWindow.closed) {
                wikiWindow.location.href = wikiUrl;
                wikiWindow.focus();
            } else {
                wikiWindow = window.open(wikiUrl, "SiIvaWiki", "width=800,height=900,left=0,top=0");
                if (!wikiWindow) {
                    console.warn("Wiki window popup blocked!");
                    alert("Please allow popups for this site to view Wiki pages.");
                }
            }

            // 2. Conditionally Find and Open YouTube Video for 'rip' nodes
            if (node.type === 'rip') { // Only open YouTube if it's a Rip node
                try {
                    const data = await fetchApi({
                        action: 'query',
                        prop: 'revisions',
                        titles: title,
                        rvprop: 'content',
                        format: 'json',
                        rvslots: 'main' // Modern mediawiki usually requires this
                    });

                    const pages = data.query.pages;
                    const pageId = Object.keys(pages)[0];
                    if (pageId !== "-1") {
                        const page = pages[pageId];
                        let content = "";
                        if (page.revisions && page.revisions[0]) {
                            if (page.revisions[0].slots) {
                                content = page.revisions[0].slots.main['*'];
                            } else {
                                content = page.revisions[0]['*'];
                            }
                        }
                        
                        let videoId = null;
                        
                        // Try 1: Check for |id=
                        const idMatch = /\|\s*id\s*=\s*([a-zA-Z0-9_-]+)/i.exec(content);
                        if (idMatch) {
                            videoId = idMatch[1];
                        } else {
                            // Try 2: Check for |link= which might contain just the ID or a full URL
                            const linkMatch = /\|\s*link\s*=\s*(?:(?:https?:\/\/)?(?:www\.)?(?:youtube\.com\/watch\?v=|youtu\.be\/))?([a-zA-Z0-9_-]+)/i.exec(content);
                            if (linkMatch) {
                                videoId = linkMatch[1];
                            }
                        }

                        if (videoId) {
                            const ytUrl = `https://www.youtube.com/watch?v=${videoId}`;
                            if (youtubeWindow && !youtubeWindow.closed) {
                                youtubeWindow.location.href = ytUrl;
                                youtubeWindow.focus();
                            } else {
                                youtubeWindow = window.open(ytUrl, "SiIvaYouTube", "width=600,height=400,left=810,top=0");
                                if (!youtubeWindow) {
                                    console.warn("YouTube window popup blocked!");
                                    alert("Please allow popups for this site to view YouTube videos.");
                                }
                            }
                        }
                    }
                } catch (e) {
                    console.error("Error finding video:", e);
                }
            }
        }

        // --- Sync Graph Data to Pixi ---
        function updatePixiObjects() {
            // Remove sprites for deleted nodes
            const currentIds = new Set(nodes.map(n => n.id));
            for (const [id, sprite] of nodeSprites) {
                if (!currentIds.has(id)) {
                    nodeContainer.removeChild(sprite);
                    sprite.destroy(); // memory cleanup
                    nodeSprites.delete(id);
                }
            }

            // Add sprites for new nodes
            nodes.forEach(n => {
                if (!nodeSprites.has(n.id)) {
                    const tex = n.type === 'category' ? catTexture : ripTexture;
                    const sprite = new PIXI.Sprite(tex);
                    sprite.anchor.set(0.5);
                    sprite.eventMode = 'static'; // Interactive
                    sprite.cursor = 'pointer';
                    
                    // Data reference
                    sprite.nodeData = n; 

                    // Interactions
                    sprite.on('pointerdown', onDragStart);
                    sprite.on('pointerup', onDragEnd);
                    sprite.on('pointerupoutside', onDragEnd);
                    sprite.on('globalmousemove', onDragMove); // Pixi standard drag
                    
                    sprite.on('click', (e) => {
                        if (dragState.isDragging) return;
                        showPage(n);
                        expandNode(n);
                    });
                    
                    sprite.on('rightclick', (e) => {
                         handleRightClick(n);
                    });

                    sprite.on('pointerover', (e) => {
                        const globalPos = sprite.getGlobalPosition();
                        tooltip.style.display = 'block';
                        tooltip.innerText = n.id.replace(/^Category:/, '');
                        // HTML tooltip positioning
                        tooltip.style.left = (globalPos.x + 15) + 'px';
                        tooltip.style.top = (globalPos.y - 10) + 'px';
                    });

                    sprite.on('pointerout', () => {
                        tooltip.style.display = 'none';
                    });

                    nodeContainer.addChild(sprite);
                    nodeSprites.set(n.id, sprite);
                    
                    // Set initial position
                    sprite.x = n.x;
                    sprite.y = n.y;
                }
            });

            // Update Counts
            document.getElementById('nodeCount').innerText = `Nodes: ${nodes.length}`;
        }

        // --- Interaction Handling (Zoom/Pan & Drag) ---
        
        // We use D3 Zoom on the Canvas DOM element to control the Pixi Viewport
        const zoom = d3.zoom()
            .scaleExtent([0.1, 8])
            .on("zoom", (event) => {
                viewport.scale.set(event.transform.k);
                viewport.position.set(event.transform.x, event.transform.y);
            });
        
        d3.select(app.view).call(zoom)
            .on("dblclick.zoom", null);

        // Drag Logic (Pixi)
        let dragState = { isDragging: false, data: null, sprite: null };

        function onDragStart(event) {
            // Prevent D3 Zoom from taking over
            // event.originalEvent.stopPropagation(); // Might interfere
            
            simulation.alphaTarget(0.3).restart();
            this.nodeData.fx = this.nodeData.x;
            this.nodeData.fy = this.nodeData.y;
            
            dragState.isDragging = true;
            dragState.data = event.data;
            dragState.sprite = this;
            
            // Disable zoom while dragging node
            d3.select(app.view).on(".zoom", null);
        }

        function onDragEnd() {
            if (!dragState.isDragging) return;
            
            simulation.alphaTarget(0);
            if (dragState.sprite && dragState.sprite.nodeData) {
                dragState.sprite.nodeData.fx = null;
                dragState.sprite.nodeData.fy = null;
            }
            
            dragState.isDragging = false;
            dragState.data = null;
            dragState.sprite = null;

            // Re-enable zoom
            d3.select(app.view).call(zoom).on("dblclick.zoom", null);
        }

        function onDragMove() {
            if (dragState.isDragging && dragState.sprite) {
                // Get local position in viewport (accounting for zoom/pan)
                const newPosition = dragState.data.getLocalPosition(viewport);
                dragState.sprite.nodeData.fx = newPosition.x;
                dragState.sprite.nodeData.fy = newPosition.y;
            }
        }

        // --- Core Logic (Same as before) ---
        
        window.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                abortExpansion = true;
                // Visual feedback?
                console.log("Expansion aborted by user.");
            }
        });

        async function fetchApi(params) {
            const url = new URL(API_BASE);
            url.search = new URLSearchParams({ ...params, origin: '*' });
            const response = await fetch(url);
            if (!response.ok) throw new Error(`API Error: ${response.statusText}`);
            return response.json();
        }

        async function getPageCategories(title) {
            const data = await fetchApi({
                action: 'query', format: 'json', prop: 'categories', titles: title, cllimit: 'max', clshow: '!hidden'
            });
            if (!data.query || !data.query.pages) return null; // Error/Missing
            const pages = data.query.pages;
            const pageId = Object.keys(pages)[0];
            if (pageId === "-1") return null; // Page doesn't exist
            return (pages[pageId].categories || []).map(c => ({ title: c.title, ns: c.ns }));
        }

        async function getCategoryMembers(title) {
            let allMembers = [];
            let continueToken = null;
            let pageExists = true; // Assume exists unless proven otherwise (list queries are tricky)

            // Initial check to see if category page exists? 
            // categorymembers list doesn't explicitly fail if cat missing, just returns empty.
            // But we can check if title is valid via basic query first?
            // Optimization: Just assume empty list = valid empty category unless we want strict checking.
            // BUT user wants "doesn't correspond to actual page".
            // Let's do a quick check for existence first if we want to be sure.
            
            // Actually, let's keep it simple: If list is empty, we can't be sure if it's empty or missing without a prop=info check.
            // Let's update `getPageCategories` first as that's the main entry for "Rips".
            
            // For categories, `categorymembers` returns empty if empty OR missing.
            // Let's leave getCategoryMembers returning [] for now, as usually you add Rips.
            // If the user adds a Category manually, we can check `getPageCategories` (prop=info) logic.
            
            // Revisiting the logic: The user prompt implies "If a node ADDED...".
            // If I add "Category:Fake", it has 0 members. Should it delete?
            // Probably yes, if it's invalid.
            
            // Let's try to infer from the first request.
            // If I modify getCategoryMembers to just return [], expandNode logic will be simpler if we handle specific Rip deletion first.
            
            do {
                const params = {
                    action: 'query',
                    format: 'json',
                    list: 'categorymembers',
                    cmtitle: title,
                    cmlimit: 'max', // Usually 500
                    cmnamespace: '0|14'
                };
                
                if (continueToken) {
                    params.cmcontinue = continueToken;
                }

                const data = await fetchApi(params);
                
                // If it's the first request and we get nothing, is it missing?
                // The API doesn't tell us easily in list mode.
                // We'll trust the User Input verification step to catch most.
                // But for `getPageCategories` (Rips), the -1 check is robust.
                
                if (data.query && data.query.categorymembers) {
                    allMembers = allMembers.concat(data.query.categorymembers);
                }

                if (data.continue && data.continue.cmcontinue) {
                    continueToken = data.continue.cmcontinue;
                } else {
                    continueToken = null;
                }

            } while (continueToken);

            return allMembers.map(c => ({ title: c.title, ns: c.ns }));
        }

        function addNode(id, type, x, y) {
            let existing = nodes.find(n => n.id === id);
            if (existing) return existing;
            const newNode = { 
                id: id, type: type, x: x || 0, y: y || 0, degree: 0, visited: false
            };
            nodes.push(newNode);
            return newNode;
        }

        function addLink(sourceId, targetId) {
            const exists = links.some(l => 
                (l.source.id === sourceId && l.target.id === targetId) ||
                (l.source === sourceId && l.target === targetId)
            );
            if (!exists) {
                links.push({ source: sourceId, target: targetId });
                const sNode = nodes.find(n => n.id === sourceId);
                const tNode = nodes.find(n => n.id === targetId);
                if(sNode) sNode.degree++;
                if(tNode) tNode.degree++;
                return true;
            }
            return false;
        }

        function restartSimulation() {
            simulation.nodes(nodes);
            simulation.force("link").links(links);
            simulation.alpha(1).restart();
            updatePixiObjects();
        }

        async function expandNode(d) {
            if (d.expanding) return;
            d.expanding = true;
            d.visited = true; // Mark as visited/expanded
            d.vibrationStart = Date.now();
            
            try {
                let newNeighbors = [];
                if (d.type === 'rip') {
                    const categories = await getPageCategories(d.id);
                    if (categories === null) {
                        // Page does not exist -> Pop out of existence
                        nodes = nodes.filter(n => n.id !== d.id);
                        links = links.filter(l => l.source.id !== d.id && l.target.id !== d.id);
                        restartSimulation();
                        return;
                    }
                    newNeighbors = categories.map(cat => ({ ...cat, direction: 'parent' }));
                } else {
                    const members = await getCategoryMembers(d.id);
                    // For categories, empty list usually just means empty/missing, difficult to distinguish without extra call.
                    // We'll treat empty as valid for now unless we add an existence check.
                    newNeighbors = members.map(mem => ({ ...mem, direction: 'child' }));
                }

                d.vibrationStart = null;
                // Check abort before starting loop
                if (abortExpansion) return;

                const angleStep = (2 * Math.PI) / (newNeighbors.length || 1);
                
                let currentDelay = 20;

                for (let i = 0; i < newNeighbors.length; i++) {
                    if (abortExpansion) break; // Check abort inside loop

                    const n = newNeighbors[i];
                    const type = n.ns === 14 ? 'category' : 'rip';
                    // Random angle for initial position
                    const angle = Math.random() * 2 * Math.PI; 
                    const dist = 50 + Math.random() * 50; // Random distance between 50 and 100
                    const nx = d.x + Math.cos(angle) * dist;
                    const ny = d.y + Math.sin(angle) * dist;
                    
                    const nodeObj = addNode(n.title, type, nx, ny);
                    let added = false;
                    
                    if (d.type === 'rip') {
                        if (addLink(nodeObj.id, d.id)) added = true;
                    } else {
                        if (addLink(d.id, nodeObj.id)) added = true;
                    }

                    if (added) {
                        restartSimulation();
                        await new Promise(r => setTimeout(r, currentDelay));
                        currentDelay = Math.max(0, currentDelay * 0.9); // Accelerate down to 0ms
                    }
                }
            } catch (e) {
                console.error(e);
                d.vibrationStart = null;
            } finally {
                d.expanding = false;
            }
        }

        async function handleRightClick(clickedNode) {
            const neighbors = [];
            links.forEach(l => {
                if (l.source.id === clickedNode.id) neighbors.push(l.target);
                else if (l.target.id === clickedNode.id) neighbors.push(l.source);
            });

            const nodesToRemove = new Set();
            if (neighbors.length <= 1) nodesToRemove.add(clickedNode.id);
            else {
                let foundLeaf = false;
                neighbors.forEach(neighbor => {
                    let degree = 0;
                    links.forEach(l => {
                        if (l.source.id === neighbor.id || l.target.id === neighbor.id) degree++;
                    });
                    if (degree === 1) {
                        nodesToRemove.add(neighbor.id);
                        foundLeaf = true;
                    }
                });
                
                // If no leaves were found to prune, delete the hub itself
                if (!foundLeaf) {
                    nodesToRemove.add(clickedNode.id);
                }
            }

            if (nodesToRemove.size > 0) {
                const toRemoveList = Array.from(nodesToRemove);
                let currentDelay = 20;

                for (const nodeId of toRemoveList) {
                    nodes = nodes.filter(n => n.id !== nodeId);
                    links = links.filter(l => l.source.id !== nodeId && l.target.id !== nodeId);
                    
                    // Recalc degrees
                    nodes.forEach(n => n.degree = 0);
                    links.forEach(l => {
                        const s = nodes.find(n => n.id === (l.source.id || l.source));
                        const t = nodes.find(n => n.id === (l.target.id || l.target));
                        if (s) s.degree++;
                        if (t) t.degree++;
                    });

                    restartSimulation();
                    await new Promise(r => setTimeout(r, currentDelay));
                    currentDelay = Math.max(0, currentDelay * 0.9);
                }
                tooltip.style.display = 'none'; // Hide tooltip after deletion
            }
        }

        // --- Window Resize ---
        window.addEventListener('resize', () => {
            app.renderer.resize(window.innerWidth, window.innerHeight);
            simulation.force("center", d3.forceCenter(window.innerWidth / 2, window.innerHeight / 2));
            simulation.alpha(1).restart();
        });

        // --- Controls Events ---
        
        async function handleAddNode(inputValue, isExplicitCategory) {
            let val = inputValue.trim();
            if(!val) return;

            // Prepend Category: if explicitly requested and missing
            if (isExplicitCategory && !val.startsWith("Category:")) {
                val = "Category:" + val;
            }

            try {
                // Check namespace via API
                const data = await fetchApi({
                    action: 'query',
                    format: 'json',
                    titles: val,
                    redirects: 1
                });
                
                if (data.query && data.query.pages) {
                    const pages = data.query.pages;
                    const pageId = Object.keys(pages)[0];
                    if (pageId !== "-1") {
                        const page = pages[pageId];
                        val = page.title;
                        const ns = page.ns;
                        const type = ns === 14 ? 'category' : 'rip';
                        
                        const node = addNode(val, type, window.innerWidth/2, window.innerHeight/2);
                        restartSimulation();
                        expandNode(node);
                        return;
                    }
                }
                
                // Fallback
                const type = val.startsWith("Category:") ? 'category' : 'rip';
                const node = addNode(val, type, window.innerWidth/2, window.innerHeight/2);
                restartSimulation();
                expandNode(node);

            } catch (e) {
                console.error("Error checking page type:", e);
                const type = val.startsWith("Category:") ? 'category' : 'rip';
                const node = addNode(val, type, window.innerWidth/2, window.innerHeight/2);
                restartSimulation();
                expandNode(node);
            }
        }

        document.getElementById('addPageBtn').addEventListener('click', () => {
            handleAddNode(document.getElementById('pageInput').value, false);
        });
        
        document.getElementById('addCatBtn').addEventListener('click', () => {
            handleAddNode(document.getElementById('catInput').value, true);
        });

        // Enter key support
        document.getElementById('pageInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') handleAddNode(e.target.value, false);
        });
        document.getElementById('catInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') handleAddNode(e.target.value, true);
        });

        document.getElementById('centerForce').addEventListener('input', (e) => {
            const v = +e.target.value;
            document.getElementById('centerForceVal').innerText = v;
            simulation.force("x").strength(v);
            simulation.force("y").strength(v);
            simulation.alpha(1).restart();
        });
        document.getElementById('repelForce').addEventListener('input', (e) => {
            const v = +e.target.value;
            document.getElementById('repelForceVal').innerText = v;
            simulation.force("charge").strength(-v);
            simulation.alpha(1).restart();
        });
        document.getElementById('linkForce').addEventListener('input', (e) => {
            const v = +e.target.value;
            document.getElementById('linkForceVal').innerText = v;
            simulation.force("link").strength(v);
            simulation.alpha(1).restart();
        });
        document.getElementById('linkDistance').addEventListener('input', (e) => {
            const v = +e.target.value;
            document.getElementById('linkDistanceVal').innerText = v;
            linkDistanceBase = v;
            simulation.force("link").distance(getLinkDistance);
            simulation.alpha(1).restart();
        });

        // --- Init ---
        (function init() {
            document.getElementById('pageInput').value = INITIAL_RIP;
            addNode(INITIAL_RIP, 'rip', window.innerWidth/2, window.innerHeight/2);
            restartSimulation();
        })();

    </script>
</body>
</html>