<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SiIvaGunner Rip Graph (WebGL/PixiJS)</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.3.2/pixi.min.js"></script>
    <style>
        body {
            margin: 0;
            background-color: #1e1e1e;
            color: #ccc;
            font-family: sans-serif;
            overflow: hidden;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        .controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(30, 30, 30, 0.9);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #444;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            max-width: 300px;
        }
        .control-group {
            display: flex;
            flex-direction: column;
        }
        .control-group label {
            margin-bottom: 5px;
            font-size: 12px;
            color: #aaa;
        }
        .control-group input[type="range"] {
            width: 100%;
        }
        .help-text {
            font-size: 11px;
            color: #aaa;
            margin-bottom: 12px;
            line-height: 1.4;
            border-bottom: 1px solid #444;
            padding-bottom: 8px;
        }
        .help-text strong {
            color: #69b3a2;
        }
        .input-group {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
            border-bottom: 1px solid #555;
            padding-bottom: 10px;
        }
        .input-group input[type="text"] {
            background: #333;
            border: 1px solid #555;
            color: #eee;
            padding: 5px;
            border-radius: 4px;
            flex-grow: 1;
        }
        .input-group button {
            background: #69b3a2;
            border: none;
            color: #fff;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
        }
        .input-group button:hover {
            background: #5aa090;
        }
        .legend {
            display: flex;
            gap: 10px;
            font-size: 11px;
            margin-bottom: 5px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .legend-color {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }
        /* HTML Tooltip for better text rendering/handling than Pixi text */
        #tooltip {
            position: absolute;
            background: rgba(30, 30, 30, 0.9);
            color: #eee;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            display: none;
            z-index: 200;
            border: 1px solid #555;
            box-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body>
    <div id="tooltip"></div>

    <div class="controls">
        <div class="help-text">
            <strong>Left-click</strong> node to fetch connections.<br>
            <strong>Right-click</strong> node to prune.<br>
            <strong>Drag</strong> background to pan, wheel to zoom.<br>
            <span id="nodeCount" style="color: #fff;">Nodes: 0</span>
        </div>
        
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: #4a90e2;"></div>
                <span>Rip (Page)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #ff9f43;"></div>
                <span>Category</span>
            </div>
        </div>

        <div class="input-group">
            <input type="text" id="startPhrase" placeholder="Page Title" value="">
            <button id="addNodeBtn">Add</button>
        </div>
        
        <div class="control-group">
            <label for="centerForce">Center Force: <span id="centerForceVal">0.01</span></label>
            <input type="range" id="centerForce" min="0" max="0.2" step="0.001" value="0.01">
        </div>
        <div class="control-group">
            <label for="repelForce">Repel Force: <span id="repelForceVal">100</span></label>
            <input type="range" id="repelForce" min="0" max="1000" value="100">
        </div>
        <div class="control-group">
            <label for="linkForce">Link Force: <span id="linkForceVal">0.05</span></label>
            <input type="range" id="linkForce" min="0" max="1" step="0.05" value="0.05">
        </div>
        <div class="control-group">
            <label for="linkDistance">Link Distance: <span id="linkDistanceVal">25</span></label>
            <input type="range" id="linkDistance" min="10" max="300" value="25">
        </div>
    </div>

    <script>
        // --- Configuration ---
        const NODE_RADIUS = 10;
        const INITIAL_RIP = "Athletic Theme (PAL Version) - Super Mario World";
        const API_BASE = "https://siivagunner.wiki/w/api.php";
        
        // --- State ---
        let nodes = [];
        let links = [];
        let linkDistanceBase = 25;
        let tooltip = document.getElementById('tooltip');

        // --- PixiJS Setup ---
        const app = new PIXI.Application({
            width: window.innerWidth,
            height: window.innerHeight,
            antialias: true,
            backgroundColor: 0x1e1e1e,
            resolution: window.devicePixelRatio || 1,
            autoDensity: true,
        });
        document.body.appendChild(app.view);

        // Container for the graph (moves with zoom)
        const viewport = new PIXI.Container();
        app.stage.addChild(viewport);
        
        // Layers
        const linkGraphics = new PIXI.Graphics();
        const nodeContainer = new PIXI.Container();
        viewport.addChild(linkGraphics);
        viewport.addChild(nodeContainer);

        // Textures (Generated once for performance)
        function createCircleTexture(color, radius) {
            const gr = new PIXI.Graphics();
            gr.beginFill(color);
            gr.lineStyle(1.5, 0xffffff);
            gr.drawCircle(0, 0, radius);
            gr.endFill();
            return app.renderer.generateTexture(gr);
        }
        
        const ripTexture = createCircleTexture(0x4a90e2, NODE_RADIUS);
        const catTexture = createCircleTexture(0xff9f43, NODE_RADIUS);
        const ripTextureVibrate = createCircleTexture(0x4a90e2, NODE_RADIUS + 1); // Slight larger for effect
        const catTextureVibrate = createCircleTexture(0xff9f43, NODE_RADIUS + 1);

        // Map to keep track of sprites {nodeId: Sprite}
        const nodeSprites = new Map();

        // --- D3 Simulation ---
        const simulation = d3.forceSimulation(nodes)
            .force("link", d3.forceLink(links).id(d => d.id).distance(getLinkDistance).strength(0.05))
            .force("charge", d3.forceManyBody().strength(-100))
            .force("center", d3.forceCenter(window.innerWidth / 2, window.innerHeight / 2))
            .force("x", d3.forceX(window.innerWidth / 2).strength(0.01))
            .force("y", d3.forceY(window.innerHeight / 2).strength(0.01));

        function getLinkDistance(d) {
            const source = d.source;
            const target = d.target;
            let dist = linkDistanceBase;
            if (source.type === 'category' && target.type === 'category') dist *= 2.0;
            else if (source.type === 'category' || target.type === 'category') dist *= 1.2;
            else dist *= 0.8;
            
            const combinedDegree = (source.degree || 0) + (target.degree || 0);
            if (combinedDegree > 5) dist += Math.min(combinedDegree * 2, 100);
            return dist;
        }

        // --- Render Loop ---
        app.ticker.add(() => {
            const now = Date.now();

            // 1. Update Node Sprites positions
            simulation.tick(); // Manually tick D3? Or let D3 internal timer run?
            // Actually D3 has its own timer. If we use simulation.on("tick"), it runs independently.
            // But syncing with Pixi ticker is smoother. We'll disable D3 internal timer and call tick manually here.
        });
        
        simulation.stop(); // Stop internal timer, we drive it with Pixi

        app.ticker.add((delta) => {
            // Run Physics
            simulation.tick(); 
            const now = Date.now();

            // Draw Links
            linkGraphics.clear();
            linkGraphics.lineStyle(1, 0x999999, 0.6);

            links.forEach(l => {
                let sx = l.source.x, sy = l.source.y;
                let tx = l.target.x, ty = l.target.y;

                // Jitter logic
                if (l.source.vibrationStart) {
                    const e = now - l.source.vibrationStart;
                    const i = Math.min(e * 0.02, 5);
                    sx += (Math.random() - 0.5) * i;
                    sy += (Math.random() - 0.5) * i;
                }
                if (l.target.vibrationStart) {
                    const e = now - l.target.vibrationStart;
                    const i = Math.min(e * 0.02, 5);
                    tx += (Math.random() - 0.5) * i;
                    ty += (Math.random() - 0.5) * i;
                }

                linkGraphics.moveTo(sx, sy);
                linkGraphics.lineTo(tx, ty);
            });

            // Update Nodes
            nodes.forEach(n => {
                let sprite = nodeSprites.get(n.id);
                
                // Create sprite if missing (should be handled in sync logic, but safety check)
                if (!sprite) return; 

                let dx = 0, dy = 0;
                
                // Vibration Logic & Visuals
                if (n.vibrationStart) {
                    const elapsed = now - n.vibrationStart;
                    const intensity = Math.min(elapsed * 0.02, 5);
                    dx = (Math.random() - 0.5) * intensity;
                    dy = (Math.random() - 0.5) * intensity;
                    
                    // Change texture/tint for loading effect
                    sprite.tint = 0xffcc00;
                    sprite.scale.set(1.1);
                } else {
                    sprite.tint = 0xffffff;
                    sprite.scale.set(1.0);
                }

                sprite.x = n.x + dx;
                sprite.y = n.y + dy;
            });
        });

        // --- Sync Graph Data to Pixi ---
        function updatePixiObjects() {
            // Remove sprites for deleted nodes
            const currentIds = new Set(nodes.map(n => n.id));
            for (const [id, sprite] of nodeSprites) {
                if (!currentIds.has(id)) {
                    nodeContainer.removeChild(sprite);
                    sprite.destroy(); // memory cleanup
                    nodeSprites.delete(id);
                }
            }

            // Add sprites for new nodes
            nodes.forEach(n => {
                if (!nodeSprites.has(n.id)) {
                    const tex = n.type === 'category' ? catTexture : ripTexture;
                    const sprite = new PIXI.Sprite(tex);
                    sprite.anchor.set(0.5);
                    sprite.eventMode = 'static'; // Interactive
                    sprite.cursor = 'pointer';
                    
                    // Data reference
                    sprite.nodeData = n; 

                    // Interactions
                    sprite.on('pointerdown', onDragStart);
                    sprite.on('pointerup', onDragEnd);
                    sprite.on('pointerupoutside', onDragEnd);
                    sprite.on('globalmousemove', onDragMove); // Pixi standard drag
                    
                    sprite.on('click', (e) => {
                        if (dragState.isDragging) return;
                        expandNode(n);
                    });
                    
                    sprite.on('rightclick', (e) => {
                         handleRightClick(n);
                    });

                    sprite.on('pointerover', (e) => {
                        const globalPos = sprite.getGlobalPosition();
                        tooltip.style.display = 'block';
                        tooltip.innerText = n.id.replace(/^Category:/, '');
                        // HTML tooltip positioning
                        tooltip.style.left = (globalPos.x + 15) + 'px';
                        tooltip.style.top = (globalPos.y - 10) + 'px';
                    });

                    sprite.on('pointerout', () => {
                        tooltip.style.display = 'none';
                    });

                    nodeContainer.addChild(sprite);
                    nodeSprites.set(n.id, sprite);
                    
                    // Set initial position
                    sprite.x = n.x;
                    sprite.y = n.y;
                }
            });

            // Update Counts
            document.getElementById('nodeCount').innerText = `Nodes: ${nodes.length}`;
        }

        // --- Interaction Handling (Zoom/Pan & Drag) ---
        
        // We use D3 Zoom on the Canvas DOM element to control the Pixi Viewport
        const zoom = d3.zoom()
            .scaleExtent([0.1, 8])
            .on("zoom", (event) => {
                viewport.scale.set(event.transform.k);
                viewport.position.set(event.transform.x, event.transform.y);
            });
        
        d3.select(app.view).call(zoom)
            .on("dblclick.zoom", null);

        // Drag Logic (Pixi)
        let dragState = { isDragging: false, data: null, sprite: null };

        function onDragStart(event) {
            // Prevent D3 Zoom from taking over
            // event.originalEvent.stopPropagation(); // Might interfere
            
            simulation.alphaTarget(0.3).restart();
            this.nodeData.fx = this.nodeData.x;
            this.nodeData.fy = this.nodeData.y;
            
            dragState.isDragging = true;
            dragState.data = event.data;
            dragState.sprite = this;
            
            // Disable zoom while dragging node
            d3.select(app.view).on(".zoom", null);
        }

        function onDragEnd() {
            if (!dragState.isDragging) return;
            
            simulation.alphaTarget(0);
            if (dragState.sprite && dragState.sprite.nodeData) {
                dragState.sprite.nodeData.fx = null;
                dragState.sprite.nodeData.fy = null;
            }
            
            dragState.isDragging = false;
            dragState.data = null;
            dragState.sprite = null;

            // Re-enable zoom
            d3.select(app.view).call(zoom).on("dblclick.zoom", null);
        }

        function onDragMove() {
            if (dragState.isDragging && dragState.sprite) {
                // Get local position in viewport (accounting for zoom/pan)
                const newPosition = dragState.data.getLocalPosition(viewport);
                dragState.sprite.nodeData.fx = newPosition.x;
                dragState.sprite.nodeData.fy = newPosition.y;
            }
        }

        // --- Core Logic (Same as before) ---
        
        async function fetchApi(params) {
            const url = new URL(API_BASE);
            url.search = new URLSearchParams({ ...params, origin: '*' });
            const response = await fetch(url);
            if (!response.ok) throw new Error(`API Error: ${response.statusText}`);
            return response.json();
        }

        async function getPageCategories(title) {
            const data = await fetchApi({
                action: 'query', format: 'json', prop: 'categories', titles: title, cllimit: 'max', clshow: '!hidden'
            });
            if (!data.query || !data.query.pages) return [];
            const pages = data.query.pages;
            const pageId = Object.keys(pages)[0];
            if (pageId === "-1") return [];
            return (pages[pageId].categories || []).map(c => ({ title: c.title, ns: c.ns }));
        }

        async function getCategoryMembers(title) {
            const data = await fetchApi({
                action: 'query', format: 'json', list: 'categorymembers', cmtitle: title, cmlimit: 'max', cmnamespace: '0|14'
            });
            if (!data.query || !data.query.categorymembers) return [];
            return (data.query.categorymembers || []).map(c => ({ title: c.title, ns: c.ns }));
        }

        function addNode(id, type, x, y) {
            let existing = nodes.find(n => n.id === id);
            if (existing) return existing;
            const newNode = { 
                id: id, type: type, x: x || 0, y: y || 0, degree: 0 
            };
            nodes.push(newNode);
            return newNode;
        }

        function addLink(sourceId, targetId) {
            const exists = links.some(l => 
                (l.source.id === sourceId && l.target.id === targetId) ||
                (l.source === sourceId && l.target === targetId)
            );
            if (!exists) {
                links.push({ source: sourceId, target: targetId });
                const sNode = nodes.find(n => n.id === sourceId);
                const tNode = nodes.find(n => n.id === targetId);
                if(sNode) sNode.degree++;
                if(tNode) tNode.degree++;
                return true;
            }
            return false;
        }

        function restartSimulation() {
            simulation.nodes(nodes);
            simulation.force("link").links(links);
            simulation.alpha(1).restart();
            updatePixiObjects();
        }

        async function expandNode(d) {
            if (d.expanding) return;
            d.expanding = true;
            d.vibrationStart = Date.now();
            
            try {
                let newNeighbors = [];
                if (d.type === 'rip') {
                    const categories = await getPageCategories(d.id);
                    newNeighbors = categories.map(cat => ({ ...cat, direction: 'parent' }));
                } else {
                    const members = await getCategoryMembers(d.id);
                    newNeighbors = members.map(mem => ({ ...mem, direction: 'child' }));
                }

                d.vibrationStart = null;
                const angleStep = (2 * Math.PI) / (newNeighbors.length || 1);
                
                for (let i = 0; i < newNeighbors.length; i++) {
                    const n = newNeighbors[i];
                    const type = n.ns === 14 ? 'category' : 'rip';
                    const angle = i * angleStep;
                    const dist = 50;
                    const nx = d.x + Math.cos(angle) * dist;
                    const ny = d.y + Math.sin(angle) * dist;
                    
                    const nodeObj = addNode(n.title, type, nx, ny);
                    let added = false;
                    
                    if (d.type === 'rip') {
                        if (addLink(nodeObj.id, d.id)) added = true;
                    } else {
                        if (addLink(d.id, nodeObj.id)) added = true;
                    }

                    if (added) {
                        restartSimulation();
                        await new Promise(r => setTimeout(r, 20));
                    }
                }
            } catch (e) {
                console.error(e);
                d.vibrationStart = null;
            } finally {
                d.expanding = false;
            }
        }

        function handleRightClick(clickedNode) {
            const neighbors = [];
            links.forEach(l => {
                if (l.source.id === clickedNode.id) neighbors.push(l.target);
                else if (l.target.id === clickedNode.id) neighbors.push(l.source);
            });

            const nodesToRemove = new Set();
            if (neighbors.length <= 1) nodesToRemove.add(clickedNode.id);
            else {
                neighbors.forEach(neighbor => {
                    let degree = 0;
                    links.forEach(l => {
                        if (l.source.id === neighbor.id || l.target.id === neighbor.id) degree++;
                    });
                    if (degree === 1) nodesToRemove.add(neighbor.id);
                });
            }

            if (nodesToRemove.size > 0) {
                nodes = nodes.filter(n => !nodesToRemove.has(n.id));
                links = links.filter(l => !nodesToRemove.has(l.source.id) && !nodesToRemove.has(l.target.id));
                
                // Recalc degrees
                nodes.forEach(n => n.degree = 0);
                links.forEach(l => {
                    const s = nodes.find(n => n.id === (l.source.id || l.source));
                    const t = nodes.find(n => n.id === (l.target.id || l.target));
                    if (s) s.degree++;
                    if (t) t.degree++;
                });

                restartSimulation();
            }
        }

        // --- Window Resize ---
        window.addEventListener('resize', () => {
            app.renderer.resize(window.innerWidth, window.innerHeight);
            simulation.force("center", d3.forceCenter(window.innerWidth / 2, window.innerHeight / 2));
            simulation.alpha(1).restart();
        });

        // --- Controls Events ---
        document.getElementById('addNodeBtn').addEventListener('click', () => {
            const val = document.getElementById('startPhrase').value.trim();
            if(val) {
                const type = val.startsWith("Category:") ? 'category' : 'rip';
                addNode(val, type, window.innerWidth/2, window.innerHeight/2);
                restartSimulation();
            }
        });
        document.getElementById('centerForce').addEventListener('input', (e) => {
            const v = +e.target.value;
            document.getElementById('centerForceVal').innerText = v;
            simulation.force("x").strength(v);
            simulation.force("y").strength(v);
            simulation.alpha(1).restart();
        });
        document.getElementById('repelForce').addEventListener('input', (e) => {
            const v = +e.target.value;
            document.getElementById('repelForceVal').innerText = v;
            simulation.force("charge").strength(-v);
            simulation.alpha(1).restart();
        });
        document.getElementById('linkForce').addEventListener('input', (e) => {
            const v = +e.target.value;
            document.getElementById('linkForceVal').innerText = v;
            simulation.force("link").strength(v);
            simulation.alpha(1).restart();
        });
        document.getElementById('linkDistance').addEventListener('input', (e) => {
            const v = +e.target.value;
            document.getElementById('linkDistanceVal').innerText = v;
            linkDistanceBase = v;
            simulation.force("link").distance(getLinkDistance);
            simulation.alpha(1).restart();
        });

        // --- Init ---
        (function init() {
            document.getElementById('startPhrase').value = INITIAL_RIP;
            addNode(INITIAL_RIP, 'rip', window.innerWidth/2, window.innerHeight/2);
            restartSimulation();
        })();

    </script>
</body>
</html>