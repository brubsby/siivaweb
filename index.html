<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SiIvaGunner Rip Graph (WebGL/PixiJS)</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.3.2/pixi.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsframe.js/lib/jsframe.min.js"></script>
    <style>
        .jsframe-wiki-content {
            width: 100%;
            height: 100%;
            border: none;
            background: #1e1e1e;
        }
        /* Custom Title Bar Style */
        .dark-titlebar {
            background-color: #222222 !important;
            color: #eeeeee !important;
            border-bottom: 1px solid #444;
        }
        
        .jsframe-title-button-close { 
            filter: invert(100%); 
        }
        body {
            margin: 0;
            background-color: #1e1e1e;
            color: #ccc;
            font-family: sans-serif;
            overflow: hidden;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        .controls-content {
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            background: #1e1e1e;
            color: #ccc;
            height: 100%;
            overflow-y: auto;
        }
        /* Scrollbar Styling */
        ::-webkit-scrollbar { width: 10px; height: 10px; }
        ::-webkit-scrollbar-track { background: #1e1e1e; }
        ::-webkit-scrollbar-thumb { background: #444; border-radius: 5px; }
        ::-webkit-scrollbar-thumb:hover { background: #555; }
        ::-webkit-scrollbar-corner { background: #1e1e1e; }
        
        .control-group {
            display: flex;
            flex-direction: column;
        }
        .control-group label {
            margin-bottom: 5px;
            font-size: 12px;
            color: #aaa;
        }
        .control-group input[type="range"] {
            width: 100%;
        }
        .help-text {
            font-size: 11px;
            color: #aaa;
            margin-bottom: 12px;
            line-height: 1.4;
            border-bottom: 1px solid #444;
            padding-bottom: 8px;
        }
        .help-text strong {
            color: #69b3a2;
        }
        .input-group {
            display: flex;
            gap: 5px;
            margin-bottom: 8px;
        }
        .input-group input[type="text"] {
            background: #333;
            border: 1px solid #555;
            color: #eee;
            padding: 5px;
            border-radius: 4px;
            flex-grow: 1;
        }
        .input-group button {
            background: #69b3a2;
            border: none;
            color: #fff;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
        }
        .input-group button:hover {
            background: #5aa090;
        }
        .legend {
            display: flex;
            gap: 10px;
            font-size: 11px;
            margin-bottom: 5px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .legend-color {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }
        /* HTML Tooltip for better text rendering/handling than Pixi text */
        #tooltip {
            position: absolute;
            background: rgba(30, 30, 30, 0.9);
            color: #eee;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            display: none;
            z-index: 200;
            border: 1px solid #555;
            box-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body>
    <div id="tooltip"></div>

    <script>
        // Load YouTube IFrame API
        var tag = document.createElement('script');
        tag.src = "https://www.youtube.com/iframe_api";
        var firstScriptTag = document.getElementsByTagName('script')[0];
        firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

        // --- Configuration ---
        const NODE_RADIUS = 10;
        const INITIAL_RIP = "Athletic Theme (PAL Version) - Super Mario World";
        const API_BASE = "https://siivagunner.wiki/w/api.php";
        
        // --- State ---
        let nodes = [];
        let links = [];
        let linkDistanceBase = 25;
        let tooltip = document.getElementById('tooltip');
        let abortExpansion = false;
        let globalAbortController = new AbortController();
        let controlsFrame = null;

        function wait(ms, signal) {
            return new Promise((resolve, reject) => {
                if (signal.aborted) {
                    reject(new DOMException('Aborted', 'AbortError'));
                    return;
                }
                const timer = setTimeout(resolve, ms);
                signal.addEventListener('abort', () => {
                    clearTimeout(timer);
                    reject(new DOMException('Aborted', 'AbortError'));
                }, { once: true });
            });
        }

        // --- PixiJS Setup ---
        const app = new PIXI.Application({
            width: window.innerWidth,
            height: window.innerHeight,
            antialias: true,
            backgroundColor: 0x1e1e1e,
            resolution: window.devicePixelRatio || 1,
            autoDensity: true,
        });
        document.body.appendChild(app.view);

        // Container for the graph (moves with zoom)
        const viewport = new PIXI.Container();
        app.stage.addChild(viewport);

        // Prevent default context menu on canvas
        app.view.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });
        
        // Layers
        const linkGraphics = new PIXI.Graphics();
        const nodeContainer = new PIXI.Container();
        viewport.addChild(linkGraphics);
        viewport.addChild(nodeContainer);

        // Textures (Generated once for performance)
        function createCircleTexture(color, radius) {
            const gr = new PIXI.Graphics();
            gr.beginFill(color);
            gr.lineStyle(1.5, 0xffffff);
            gr.drawCircle(0, 0, radius);
            gr.endFill();
            return app.renderer.generateTexture(gr);
        }
        
        const ripTexture = createCircleTexture(0x4a90e2, NODE_RADIUS);
        const catTexture = createCircleTexture(0xff9f43, NODE_RADIUS);
        const ripTextureVibrate = createCircleTexture(0x4a90e2, NODE_RADIUS + 1); // Slight larger for effect
        const catTextureVibrate = createCircleTexture(0xff9f43, NODE_RADIUS + 1);

        // Map to keep track of sprites {nodeId: Sprite}
        const nodeSprites = new Map();

        // --- D3 Simulation ---
        const simulation = d3.forceSimulation(nodes)
            .force("link", d3.forceLink(links).id(d => d.id).distance(getLinkDistance).strength(0.05))
            .force("charge", d3.forceManyBody().strength(-100))
            .force("center", d3.forceCenter(window.innerWidth / 2, window.innerHeight / 2))
            .force("x", d3.forceX(window.innerWidth / 2).strength(0.05))
            .force("y", d3.forceY(window.innerHeight / 2).strength(0.05));

        function getLinkDistance(d) {
            const source = d.source;
            const target = d.target;
            let dist = linkDistanceBase;
            if (source.type === 'category' && target.type === 'category') dist *= 2.0;
            else if (source.type === 'category' || target.type === 'category') dist *= 1.2;
            else dist *= 0.8;
            
            const combinedDegree = (source.degree || 0) + (target.degree || 0);
            if (combinedDegree > 5) dist += Math.min(combinedDegree * 2, 100);
            return dist;
        }

        // --- Render Loop ---
        app.ticker.add(() => {
            const now = Date.now();

            // 1. Update Node Sprites positions
            simulation.tick(); // Manually tick D3? Or let D3 internal timer run?
            // Actually D3 has its own timer. If we use simulation.on("tick"), it runs independently.
            // But syncing with Pixi ticker is smoother. We'll disable D3 internal timer and call tick manually here.
        });
        
        simulation.stop(); // Stop internal timer, we drive it with Pixi

        app.ticker.add((delta) => {
            // Run Physics
            simulation.tick(); 
            const now = Date.now();

            // Draw Links
            linkGraphics.clear();
            linkGraphics.lineStyle(1, 0x999999, 0.6);

            links.forEach(l => {
                let sx = l.source.x, sy = l.source.y;
                let tx = l.target.x, ty = l.target.y;

                // Jitter logic
                if (l.source.vibrationStart) {
                    const e = now - l.source.vibrationStart;
                    const i = Math.min(e * 0.02, 5);
                    sx += (Math.random() - 0.5) * i;
                    sy += (Math.random() - 0.5) * i;
                }
                if (l.target.vibrationStart) {
                    const e = now - l.target.vibrationStart;
                    const i = Math.min(e * 0.02, 5);
                    tx += (Math.random() - 0.5) * i;
                    ty += (Math.random() - 0.5) * i;
                }

                linkGraphics.moveTo(sx, sy);
                linkGraphics.lineTo(tx, ty);
            });

            // Update Nodes
            nodes.forEach(n => {
                let sprite = nodeSprites.get(n.id);
                
                // Create sprite if missing (should be handled in sync logic, but safety check)
                if (!sprite) return; 

                let dx = 0, dy = 0;
                
                // Vibration Logic & Visuals
                if (n.vibrationStart) {
                    const elapsed = now - n.vibrationStart;
                    const intensity = Math.min(elapsed * 0.02, 5);
                    dx = (Math.random() - 0.5) * intensity;
                    dy = (Math.random() - 0.5) * intensity;
                    
                    // Change texture/tint for loading effect
                    sprite.tint = 0xffcc00;
                    sprite.scale.set(1.1);
                    sprite.alpha = 1.0;
                } else {
                    sprite.tint = 0xffffff;
                    sprite.scale.set(1.0);
                    sprite.alpha = n.visited ? 1.0 : 0.5;
                }

                sprite.x = n.x + dx;
                sprite.y = n.y + dy;
            });
        });

        // --- Popup Logic ---
        const jsFrame = new JSFrame();
        let wikiFrame = null;
        let youtubeFrame = null;
        let currentYoutubeVideoId = null; // Track current video in YouTube frame
        let currentWikiTitle = null; // Track current wiki page title
        let showPageAbortController = null;
        
        // YouTube API Player Instance
        let ytPlayer = null;

        async function showPage(node) {
            if (showPageAbortController) {
                showPageAbortController.abort();
            }
            showPageAbortController = new AbortController();
            const signal = showPageAbortController.signal;

            const title = node.id;
            const displayTitle = title.replace(/^Category:/, '');

            // Check settings
            const showWiki = document.getElementById('showWikiCheck').checked;
            const showYoutube = document.getElementById('showYoutubeCheck').checked;

            // --- 1. Wiki Window (JSFrame) ---
            if (showWiki) {
                let needsWikiUpdate = false;

                if (!wikiFrame) {
                    wikiFrame = jsFrame.create({
                        title: 'Wiki: ' + displayTitle,
                        left: 20, top: 20, width: 600, height: 800,
                        movable: true, resizable: true,
                        html: '<iframe id="wikiInnerFrame" class="jsframe-wiki-content" name="wikiInnerFrame"></iframe>'
                    });
                    wikiFrame.setTitleBarClassName('dark-titlebar', 'dark-titlebar');
                    wikiFrame.on('close', () => { wikiFrame = null; currentWikiTitle = null; });
                    wikiFrame.show();
                    needsWikiUpdate = true;
                } else {
                    wikiFrame.setTitle('Wiki: ' + displayTitle);
                    wikiFrame.show();
                    wikiFrame.requestFocus();
                    if (currentWikiTitle !== title) {
                        needsWikiUpdate = true;
                    }
                }

                if (needsWikiUpdate) {
                    currentWikiTitle = title;
                    
                    // Show loading in Wiki Frame
                    const wikiInner = document.getElementById('wikiInnerFrame'); // JSFrame adds to DOM
                    if (wikiInner) {
                        wikiInner.srcdoc = `<div style="font-family:sans-serif;padding:20px;color:#ccc;background:#1e1e1e;height:100vh;">Loading ${displayTitle}...</div>`;
                    }

                    // Fetch Wiki Content
                    try {
                        const parseData = await fetchApi({
                            action: 'parse',
                            page: title,
                            format: 'json',
                            prop: 'text',
                            mobileformat: 1
                        }, signal);

                        if (signal.aborted) return;

                        if (parseData.parse && parseData.parse.text && wikiInner) {
                            let content = parseData.parse.text['*'];
                            // Fix relative image URLs to be absolute (handling single and double quotes)
                            content = content.replace(/src=["']\//g, 'src="https://siivagunner.wiki/');
                            content = content.replace(/srcset=["']\//g, 'srcset="https://siivagunner.wiki/');
                            content = content.replace(/, \//g, ', https://siivagunner.wiki/');
                            
                            // Remove lazy loading which can cause issues in srcdoc/iframes
                            content = content.replace(/loading="lazy"/g, '');
                            content = content.replace(/decoding="async"/g, '');

                            const html = `
                                <!DOCTYPE html>
                                <html>
                                <head>
                                    <meta name="referrer" content="no-referrer">
                                    <base href="https://siivagunner.wiki/wiki/" target="_blank">
                                    <style>
                                        /* Scrollbar Styling */
                                        ::-webkit-scrollbar { width: 10px; height: 10px; }
                                        ::-webkit-scrollbar-track { background: #1e1e1e; }
                                        ::-webkit-scrollbar-thumb { background: #444; border-radius: 5px; }
                                        ::-webkit-scrollbar-thumb:hover { background: #555; }
                                        ::-webkit-scrollbar-corner { background: #1e1e1e; }

                                        /* Core Styles */
                                        body { font-family: sans-serif; padding: 15px; color: #ccc; line-height: 1.5; background-color: #1e1e1e; }
                                        img { max-width: 100%; height: auto; }
                                        a { color: #4a90e2; text-decoration: none; }
                                        a:hover { text-decoration: underline; }
                                        h1, h2, h3, h4, h5, h6 { color: #eee; border-bottom: 1px solid #444; }
                                        .mw-parser-output { max-width: 100%; }
                                        
                                        /* Aggressive Table/Infobox Styling */
                                        table, .infobox { background-color: #222 !important; color: #ccc !important; border-color: #444 !important; }
                                        th { background-color: #333 !important; color: #eee !important; border-color: #444 !important; }
                                        td { background-color: #222 !important; color: #ccc !important; border-color: #444 !important; }
                                        caption { color: #eee !important; }
                                    </style>
                                </head>
                                <body>
                                    <h2>${displayTitle}</h2>
                                    ${content}
                                </body>
                                </html>
                            `;
                            wikiInner.srcdoc = html;
                        }
                    } catch (e) {
                        if (e.name === 'AbortError') return;
                        if(wikiInner) wikiInner.srcdoc = `<div style="color:#ff6b6b;padding:20px;background:#1e1e1e;height:100vh;">Error loading content.</div>`;
                    }
                }
            } else if (wikiFrame) {
                wikiFrame.close();
            }

            // --- 2. YouTube Window (JSFrame) ---
            if (node.type === 'rip' && showYoutube) {
                try {
                    // Fetch Raw Wikitext to find ID
                    const rawData = await fetchApi({
                        action: 'query',
                        prop: 'revisions',
                        titles: title,
                        rvprop: 'content',
                        format: 'json',
                        rvslots: 'main'
                    }, signal);

                    if (signal.aborted) return;

                    const pages = rawData.query.pages;
                    const pageId = Object.keys(pages)[0];
                    let videoId = null;

                    if (pageId !== "-1") {
                        const page = pages[pageId];
                        let rawContent = "";
                        if (page.revisions && page.revisions[0]) {
                            rawContent = page.revisions[0].slots ? page.revisions[0].slots.main['*'] : page.revisions[0]['*'];
                        }

                        const idMatch = /\|\s*id\s*=\s*([a-zA-Z0-9_-]+)/i.exec(rawContent);
                        if (idMatch) videoId = idMatch[1];
                        else {
                            // Match 'link' or 'url', optional brackets, optional YouTube prefix
                            const linkMatch = /\|\s*(?:link|url)\s*=\s*(?:\[)?(?:(?:https?:\/\/)?(?:www\.)?(?:youtube\.com\/watch\?v=|youtu\.be\/))?([a-zA-Z0-9_-]+)/i.exec(rawContent);
                            if (linkMatch) videoId = linkMatch[1];
                        }
                    }

                    if (videoId) {
                        if (!youtubeFrame) {
                            youtubeFrame = jsFrame.create({
                                title: 'YouTube Player',
                                left: 640, top: 20, width: 480, height: 320,
                                movable: true, resizable: true,
                                html: '<div id="ytPlayer"></div>'
                            });
                            youtubeFrame.setTitleBarClassName('dark-titlebar', 'dark-titlebar');
                            youtubeFrame.on('close', () => { 
                                youtubeFrame = null; 
                                if (ytPlayer) {
                                    ytPlayer.destroy();
                                    ytPlayer = null;
                                }
                                currentYoutubeVideoId = null; 
                            });
                            youtubeFrame.show();
                            
                            if (window.YT && window.YT.Player) {
                                ytPlayer = new YT.Player('ytPlayer', {
                                    height: '100%',
                                    width: '100%',
                                    videoId: videoId,
                                    playerVars: {
                                        'autoplay': 1,
                                        'origin': window.location.origin
                                    },
                                    events: {
                                        'onStateChange': onPlayerStateChange
                                    }
                                });
                            }
                            currentYoutubeVideoId = videoId;
                        } else {
                            // Update existing frame
                            youtubeFrame.show();
                            youtubeFrame.requestFocus();
                            if (currentYoutubeVideoId !== videoId && ytPlayer && ytPlayer.loadVideoById) {
                                ytPlayer.loadVideoById(videoId);
                                currentYoutubeVideoId = videoId;
                            }
                        }
                    }
                } catch (e) {
                    if (e.name !== 'AbortError') console.error("Error finding video:", e);
                }
            } else if (youtubeFrame && !showYoutube) {
                youtubeFrame.close();
            }
        }

        // --- Sync Graph Data to Pixi ---
        function updatePixiObjects() {
            // Remove sprites for deleted nodes
            const currentIds = new Set(nodes.map(n => n.id));
            for (const [id, sprite] of nodeSprites) {
                if (!currentIds.has(id)) {
                    nodeContainer.removeChild(sprite);
                    sprite.destroy(); // memory cleanup
                    nodeSprites.delete(id);
                }
            }

            // Add sprites for new nodes
            nodes.forEach(n => {
                if (!nodeSprites.has(n.id)) {
                    const tex = n.type === 'category' ? catTexture : ripTexture;
                    const sprite = new PIXI.Sprite(tex);
                    sprite.anchor.set(0.5);
                    sprite.eventMode = 'static'; // Interactive
                    sprite.cursor = 'pointer';
                    
                    // Data reference
                    sprite.nodeData = n; 

                    // Interactions
                    sprite.on('pointerdown', onDragStart);
                    sprite.on('pointerup', onDragEnd);
                    sprite.on('pointerupoutside', onDragEnd);
                    sprite.on('globalmousemove', onDragMove); // Pixi standard drag
                    
                    sprite.on('click', (e) => {
                        if (dragState.didMove) { // If there was movement, it was a drag, so don't activate
                            dragState.didMove = false; // Reset for next interaction
                            return;
                        }
                        showPage(n);
                        expandNode(n);
                    });
                    
                    sprite.on('rightclick', (e) => {
                         handleRightClick(n);
                    });

                    sprite.on('pointerover', (e) => {
                        const globalPos = sprite.getGlobalPosition();
                        tooltip.style.display = 'block';
                        tooltip.innerText = n.id.replace(/^Category:/, '');
                        // HTML tooltip positioning
                        tooltip.style.left = (globalPos.x + 15) + 'px';
                        tooltip.style.top = (globalPos.y - 10) + 'px';
                    });

                    sprite.on('pointerout', () => {
                        tooltip.style.display = 'none';
                    });

                    nodeContainer.addChild(sprite);
                    nodeSprites.set(n.id, sprite);
                    
                    // Set initial position
                    sprite.x = n.x;
                    sprite.y = n.y;
                }
            });

            // Update Counts
            document.getElementById('nodeCount').innerText = `Nodes: ${nodes.length}`;
        }

        // --- Interaction Handling (Zoom/Pan & Drag) ---
        
        // We use D3 Zoom on the Canvas DOM element to control the Pixi Viewport
        const zoom = d3.zoom()
            .scaleExtent([0.1, 8])
            .on("zoom", (event) => {
                viewport.scale.set(event.transform.k);
                viewport.position.set(event.transform.x, event.transform.y);
            });
        
        d3.select(app.view).call(zoom)
            .on("dblclick.zoom", null);

        // Drag Logic (Pixi)
        let dragState = { isDragging: false, data: null, sprite: null, didMove: false, initialPointerPos: null };
        const DRAG_THRESHOLD = 5; // Pixels to move before considered a drag

        function onDragStart(event) {
            simulation.alphaTarget(0.3).restart();
            this.nodeData.fx = this.nodeData.x;
            this.nodeData.fy = this.nodeData.y;
            
            dragState.isDragging = true;
            dragState.data = event.data;
            dragState.sprite = this;
            dragState.didMove = false; // Reset for this drag interaction
            dragState.initialPointerPos = event.data.global.clone(); // Store initial position

            d3.select(app.view).on(".zoom", null);
        }

        function onDragEnd() {
            if (!dragState.isDragging) return;
            
            simulation.alphaTarget(0);
            if (dragState.sprite && dragState.sprite.nodeData) {
                dragState.sprite.nodeData.fx = null;
                dragState.sprite.nodeData.fy = null;
            }
            
            dragState.isDragging = false;
            dragState.data = null;
            dragState.sprite = null;
            dragState.initialPointerPos = null; // Clear initial position

            // Re-enable zoom
            d3.select(app.view).call(zoom).on("dblclick.zoom", null);
        }

        function onDragMove() {
            if (dragState.isDragging && dragState.sprite) {
                const currentPointerPos = dragState.data.global;
                // Check if pointer has moved significantly from initial position
                const distance = Math.sqrt(
                    Math.pow(currentPointerPos.x - dragState.initialPointerPos.x, 2) +
                    Math.pow(currentPointerPos.y - dragState.initialPointerPos.y, 2)
                );
                if (distance > DRAG_THRESHOLD) { 
                    dragState.didMove = true;
                }

                const newPosition = dragState.data.getLocalPosition(viewport);
                dragState.sprite.nodeData.fx = newPosition.x;
                dragState.sprite.nodeData.fy = newPosition.y;
            }
        }
        // --- Core Logic (Same as before) ---
        
        window.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                abortExpansion = true;
                globalAbortController.abort();
                globalAbortController = new AbortController();
                console.log("Expansion aborted by user.");
            }
        });

        async function fetchApi(params, signal) {
            const url = new URL(API_BASE);
            url.search = new URLSearchParams({ ...params, origin: '*' });
            const response = await fetch(url, { signal });
            if (!response.ok) throw new Error(`API Error: ${response.statusText}`);
            return response.json();
        }

        async function getPageCategories(title, signal) {
            const data = await fetchApi({
                action: 'query', format: 'json', prop: 'categories', titles: title, cllimit: 'max', clshow: '!hidden'
            }, signal);
            if (!data.query || !data.query.pages) return null; // Error/Missing
            const pages = data.query.pages;
            const pageId = Object.keys(pages)[0];
            if (pageId === "-1") return null; // Page doesn't exist
            return (pages[pageId].categories || []).map(c => ({ title: c.title, ns: c.ns }));
        }

        async function getCategoryMembers(title, signal) {
            let allMembers = [];
            let continueToken = null;
            
            do {
                const params = {
                    action: 'query',
                    format: 'json',
                    list: 'categorymembers',
                    cmtitle: title,
                    cmlimit: 'max', // Usually 500
                    cmnamespace: '0|14'
                };
                
                if (continueToken) {
                    params.cmcontinue = continueToken;
                }

                const data = await fetchApi(params, signal);
                
                if (data.query && data.query.categorymembers) {
                    allMembers = allMembers.concat(data.query.categorymembers);
                }

                if (data.continue && data.continue.cmcontinue) {
                    continueToken = data.continue.cmcontinue;
                } else {
                    continueToken = null;
                }

            } while (continueToken);

            return allMembers.map(c => ({ title: c.title, ns: c.ns }));
        }

        function addNode(id, type, x, y) {
            let existing = nodes.find(n => n.id === id);
            if (existing) return existing;
            const newNode = { 
                id: id, type: type, x: x || 0, y: y || 0, degree: 0, visited: false
            };
            nodes.push(newNode);
            return newNode;
        }

        function addLink(sourceId, targetId) {
            const exists = links.some(l => 
                (l.source.id === sourceId && l.target.id === targetId) ||
                (l.source === sourceId && l.target === targetId)
            );
            if (!exists) {
                links.push({ source: sourceId, target: targetId });
                const sNode = nodes.find(n => n.id === sourceId);
                const tNode = nodes.find(n => n.id === targetId);
                if(sNode) sNode.degree++;
                if(tNode) tNode.degree++;
                return true;
            }
            return false;
        }

        function restartSimulation() {
            simulation.nodes(nodes);
            simulation.force("link").links(links);
            simulation.alpha(1).restart();
            updatePixiObjects();
        }

        async function expandNode(d) {
            if (d.expanding) return;
            d.expanding = true;
            d.visited = true; // Mark as visited/expanded
            d.vibrationStart = Date.now();
            
            // Capture the current signal for this expansion process
            const signal = globalAbortController.signal;
            
            try {
                let newNeighbors = [];
                if (d.type === 'rip') {
                    const categories = await getPageCategories(d.id, signal);
                    if (categories === null) {
                        // Page does not exist -> Pop out of existence
                        nodes = nodes.filter(n => n.id !== d.id);
                        links = links.filter(l => l.source.id !== d.id && l.target.id !== d.id);
                        restartSimulation();
                        return;
                    }
                    newNeighbors = categories.map(cat => ({ ...cat, direction: 'parent' }));
                } else {
                    const members = await getCategoryMembers(d.id, signal);
                    newNeighbors = members.map(mem => ({ ...mem, direction: 'child' }));
                }

                d.vibrationStart = null;
                if (signal.aborted) return;

                const angleStep = (2 * Math.PI) / (newNeighbors.length || 1);
                
                let currentDelay = 20;

                for (let i = 0; i < newNeighbors.length; i++) {
                    if (signal.aborted) break;

                    const n = newNeighbors[i];
                    const type = n.ns === 14 ? 'category' : 'rip';
                    // Random angle for initial position
                    const angle = Math.random() * 2 * Math.PI; 
                    const dist = 50 + Math.random() * 50; // Random distance between 50 and 100
                    const nx = d.x + Math.cos(angle) * dist;
                    const ny = d.y + Math.sin(angle) * dist;
                    
                    const nodeObj = addNode(n.title, type, nx, ny);
                    let added = false;
                    
                    if (d.type === 'rip') {
                        if (addLink(nodeObj.id, d.id)) added = true;
                    } else {
                        if (addLink(d.id, nodeObj.id)) added = true;
                    }

                    if (added) {
                        restartSimulation();
                        await wait(currentDelay, signal);
                        currentDelay = Math.max(0, currentDelay * 0.9); // Accelerate down to 0ms
                    }
                }
            } catch (e) {
                if (e.name !== 'AbortError') console.error(e);
                d.vibrationStart = null;
            } finally {
                d.expanding = false;
            }
        }

        async function handleRightClick(clickedNode) {
            const neighbors = [];
            links.forEach(l => {
                if (l.source.id === clickedNode.id) neighbors.push(l.target);
                else if (l.target.id === clickedNode.id) neighbors.push(l.source);
            });

            const nodesToRemove = new Set();
            if (neighbors.length <= 1) nodesToRemove.add(clickedNode.id);
            else {
                let foundLeaf = false;
                neighbors.forEach(neighbor => {
                    let degree = 0;
                    links.forEach(l => {
                        if (l.source.id === neighbor.id || l.target.id === neighbor.id) degree++;
                    });
                    if (degree === 1) {
                        nodesToRemove.add(neighbor.id);
                        foundLeaf = true;
                    }
                });
                
                // If no leaves were found to prune, delete the hub itself
                if (!foundLeaf) {
                    nodesToRemove.add(clickedNode.id);
                }
            }

            if (nodesToRemove.size > 0) {
                const toRemoveList = Array.from(nodesToRemove);
                let currentDelay = 20;
                const signal = globalAbortController.signal;

                try {
                    for (const nodeId of toRemoveList) {
                        if (signal.aborted) break;

                        nodes = nodes.filter(n => n.id !== nodeId);
                        links = links.filter(l => l.source.id !== nodeId && l.target.id !== nodeId);
                        
                        // Recalc degrees
                        nodes.forEach(n => n.degree = 0);
                        links.forEach(l => {
                            const s = nodes.find(n => n.id === (l.source.id || l.source));
                            const t = nodes.find(n => n.id === (l.target.id || l.target));
                            if (s) s.degree++;
                            if (t) t.degree++;
                        });

                        restartSimulation();
                        await wait(currentDelay, signal);
                        currentDelay = Math.max(0, currentDelay * 0.9);
                    }
                } catch (e) {
                     if (e.name !== 'AbortError') console.error(e);
                }
                tooltip.style.display = 'none'; // Hide tooltip after deletion
            }
        }

        // --- Window Resize ---
        window.addEventListener('resize', () => {
            app.renderer.resize(window.innerWidth, window.innerHeight);
            simulation.force("center", d3.forceCenter(window.innerWidth / 2, window.innerHeight / 2));
            simulation.alpha(1).restart();
        });

        // --- Controls Events ---
        
        async function handleAddNode(inputValue, isExplicitCategory, event) {
            let val = inputValue.trim();
            if(!val) return;

            // Prepend Category: if explicitly requested and missing
            if (isExplicitCategory && !val.startsWith("Category:")) {
                val = "Category:" + val;
            }
            
            // First, determine the final title and type by performing the API query
            let finalTitle = val;
            let finalType = isExplicitCategory ? 'category' : 'rip';
            let initialApiCallSuccess = false; // Track if the initial API call succeeds
            
            try {
                const data = await fetchApi({
                    action: 'query',
                    format: 'json',
                    titles: val,
                    redirects: 1
                }, globalAbortController.signal);

                if (data.query && data.query.pages) {
                    const pages = data.query.pages;
                    const pageId = Object.keys(pages)[0];
                    if (pageId !== "-1") {
                        const page = pages[pageId];
                        finalTitle = page.title;
                        const ns = page.ns;
                        finalType = ns === 14 ? 'category' : 'rip';
                        initialApiCallSuccess = true;
                    }
                }
            } catch (e) {
                if (e.name === 'AbortError') return;
                console.error("Error during initial API check for handleAddNode:", e);
                // If initial API call fails, we proceed with the user's input as fallback
            }

            // Check if node already exists based on finalTitle
            let existingNode = nodes.find(n => n.id === finalTitle);
            if (existingNode) {
                showPage(existingNode); // Trigger showPage for existing node
                expandNode(existingNode);
                return;
            }

            // If we reach here, the node does not exist, so proceed with animation
            let startX = window.innerWidth / 2;
            let startY = window.innerHeight / 2;
            
            if (event) {
                if (event.clientX) {
                    startX = event.clientX;
                    startY = event.clientY;
                } else if (event.target && event.target.getBoundingClientRect) {
                    const rect = event.target.getBoundingClientRect();
                    startX = rect.left + rect.width / 2;
                    startY = rect.top + rect.height / 2;
                }
            }
            
            const tempId = "Loading... " + Date.now();
            
            // Calculate velocity vector towards center
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;
            let dx = centerX - startX;
            let dy = centerY - startY;
            const dist = Math.sqrt(dx*dx + dy*dy) || 1;
            const speed = 15; // Initial burst speed
            
            const placeholderNode = addNode(tempId, isExplicitCategory ? 'category' : 'rip', startX, startY);
            placeholderNode.vx = (dx / dist) * speed;
            placeholderNode.vy = (dy / dist) * speed;
            placeholderNode.vibrationStart = Date.now(); // Start vibrating
            
            restartSimulation();

            try {
                // Now update the placeholder with the final determined title and type
                // If initialApiCallSuccess is false, it means API call failed or page doesn't exist,
                // so finalTitle will be just the user's input `val`.
                placeholderNode.id = finalTitle;
                placeholderNode.type = finalType;
                
                restartSimulation();
                expandNode(placeholderNode);

            } catch (e) {
                if (e.name === 'AbortError') {
                    // Cleanup placeholder if aborted during animation (unlikely, but safe)
                    nodes = nodes.filter(n => n.id !== tempId);
                    restartSimulation();
                    return;
                }
                console.error("Error during handleAddNode animation phase:", e);
                // If something goes wrong here, the placeholder will remain as "Loading..."
                // Or we can expand it as a fallback with its current (possibly temp) ID
                expandNode(placeholderNode);
            }
        }



        async function handleRandomNode(e, namespace = 0, type = 'rip') {
            try {
                // Fetch random rip data first
                const data = await fetchApi({
                    action: 'query',
                    format: 'json',
                    list: 'random',
                    rnnamespace: namespace,
                    rnlimit: 1
                }, globalAbortController.signal);
                
                if (data.query && data.query.random && data.query.random.length > 0) {
                    const page = data.query.random[0];
                    const val = page.title;
                    
                    // Check if node already exists
                    let existingNode = nodes.find(n => n.id === val);
                    if (existingNode) {
                        showPage(existingNode);
                        expandNode(existingNode);
                        return;
                    }

                    // Node does not exist, proceed with animation
                    const startX = e.clientX || window.innerWidth / 2;
                    const startY = e.clientY || window.innerHeight / 2;
                    const tempId = "Loading... " + Date.now();
                    
                    // Calculate velocity vector towards center
                    const centerX = window.innerWidth / 2;
                    const centerY = window.innerHeight / 2;
                    let dx = centerX - startX;
                    let dy = centerY - startY;
                    const dist = Math.sqrt(dx*dx + dy*dy) || 1;
                    const speed = 15; // Initial burst speed
                    
                    const placeholderNode = addNode(tempId, type, startX, startY);
                    placeholderNode.vx = (dx / dist) * speed;
                    placeholderNode.vy = (dy / dist) * speed;
                    placeholderNode.vibrationStart = Date.now(); // Start vibrating
                    
                    restartSimulation();

                    // Update Node
                    placeholderNode.id = val;
                    finalNode = placeholderNode; // FinalNode is a reference to placeholderNode
                    
                    restartSimulation();
                    showPage(finalNode);
                    expandNode(finalNode);
                } else {
                     // No data, do nothing
                }
            } catch (e) {
                if (e.name !== 'AbortError') console.error("Error fetching random node:", e);
                // No placeholder created yet, so no cleanup needed for placeholder if error happens before placeholder creation
                // If error happens after placeholder creation but before update, the placeholder will remain "Loading..." which is fine.
            }
        }

        function initControls() {
            const controlsHtml = `
                <div class="controls-content">
                    <div class="help-text">
                        <strong>Left-click</strong> node to fetch connections.<br>
                        <strong>Right-click</strong> node to prune leaves, and again for self.<br>
                        <strong>Drag</strong> background to pan, wheel to zoom.<br>
                        <strong>Esc</strong> to cancel expansion.<br>
                        <span id="nodeCount" style="color: #fff;">Nodes: 0</span>
                    </div>
                    
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #4a90e2;"></div>
                            <span>Rip (Page)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #ff9f43;"></div>
                            <span>Category</span>
                        </div>
                    </div>

                    <div class="input-group">
                        <input type="text" id="pageInput" placeholder="Rip Title" value="">
                        <button id="addPageBtn" style="white-space: nowrap;">Add Rip</button>
                    </div>
                    <div class="input-group">
                        <input type="text" id="catInput" placeholder="Category" value="">
                        <button id="addCatBtn" style="white-space: nowrap;">Add Cat</button>
                    </div>
                    <div class="input-group">
                        <button id="randomBtn" style="width: 100%; background: #ff9f43; white-space: nowrap;">Add Random Rip Node</button>
                    </div>
                    <div class="input-group">
                        <button id="randomCatBtn" style="width: 100%; background: #ff9f43; white-space: nowrap;">Add Random Category Node</button>
                    </div>
                    
                    <div class="control-group" style="margin-top: 10px; gap: 8px;">
                        <label style="margin: 0; cursor: pointer;"><input type="checkbox" id="showWikiCheck" checked> Sync Wiki Window</label>
                        <label style="margin: 0; cursor: pointer;"><input type="checkbox" id="showYoutubeCheck" checked> Sync YouTube Window</label>
                        <label style="margin: 0; cursor: pointer;"><input type="checkbox" id="autoplayUnvisitedCheck"> Autoplay Random Unvisited Node</label>
                    </div>

                    <div id="forceHeader" style="cursor: pointer; background: #333; padding: 8px; margin-top: 10px; border-radius: 4px; user-select: none; font-size: 12px; color: #eee; white-space: nowrap;">Graph Physics ▶</div>
                    <div id="forceControls" style="display: none; padding-left: 5px; border-left: 2px solid #333; margin-top: 5px;">
                        <div class="control-group">
                            <label for="centerForce">Center Force: <span id="centerForceVal">0.05</span></label>
                            <input type="range" id="centerForce" min="0" max="0.2" step="0.001" value="0.05">
                        </div>
                        <div class="control-group">
                            <label for="repelForce">Repel Force: <span id="repelForceVal">100</span></label>
                            <input type="range" id="repelForce" min="0" max="1000" value="100">
                        </div>
                        <div class="control-group">
                            <label for="linkForce">Link Force: <span id="linkForceVal">0.05</span></label>
                            <input type="range" id="linkForce" min="0" max="1" step="0.05" value="0.05">
                        </div>
                        <div class="control-group">
                            <label for="linkDistance">Link Distance: <span id="linkDistanceVal">25</span></label>
                            <input type="range" id="linkDistance" min="10" max="300" value="25">
                        </div>
                    </div>
                </div>
            `;

            controlsFrame = jsFrame.create({
                title: 'Controls',
                left: window.innerWidth - 320, top: 20, width: 300, height: 600,
                movable: true, resizable: true,
                html: controlsHtml
            });
            controlsFrame.setTitleBarClassName('dark-titlebar', 'dark-titlebar');
            controlsFrame.show();

            // Attach Listeners
            document.getElementById('forceHeader').addEventListener('click', (e) => {
                const content = document.getElementById('forceControls');
                const isVisible = content.style.display !== 'none';
                content.style.display = isVisible ? 'none' : 'block';
                e.target.innerText = isVisible ? 'Graph Physics ▶' : 'Graph Physics ▼';
            });

            document.getElementById('addPageBtn').addEventListener('click', (e) => {
                handleAddNode(document.getElementById('pageInput').value, false, e);
            });
            
            document.getElementById('addCatBtn').addEventListener('click', (e) => {
                handleAddNode(document.getElementById('catInput').value, true, e);
            });

            document.getElementById('pageInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') handleAddNode(e.target.value, false, e);
            });
            document.getElementById('catInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') handleAddNode(e.target.value, true, e);
            });

            document.getElementById('randomBtn').addEventListener('click', (e) => handleRandomNode(e, 0, 'rip'));
            document.getElementById('randomCatBtn').addEventListener('click', (e) => handleRandomNode(e, 14, 'category'));

            document.getElementById('centerForce').addEventListener('input', (e) => {
                const v = +e.target.value;
                document.getElementById('centerForceVal').innerText = v;
                simulation.force("x").strength(v);
                simulation.force("y").strength(v);
                simulation.alpha(1).restart();
            });
            document.getElementById('repelForce').addEventListener('input', (e) => {
                const v = +e.target.value;
                document.getElementById('repelForceVal').innerText = v;
                simulation.force("charge").strength(-v);
                simulation.alpha(1).restart();
            });
            document.getElementById('linkForce').addEventListener('input', (e) => {
                const v = +e.target.value;
                document.getElementById('linkForceVal').innerText = v;
                simulation.force("link").strength(v);
                simulation.alpha(1).restart();
            });
            document.getElementById('linkDistance').addEventListener('input', (e) => {
                const v = +e.target.value;
                document.getElementById('linkDistanceVal').innerText = v;
                linkDistanceBase = v;
                simulation.force("link").distance(getLinkDistance);
                simulation.alpha(1).restart();
            });

            document.getElementById('autoplayUnvisitedCheck').addEventListener('change', (e) => {
                if (e.target.checked) {
                    playNextRandomRip();
                }
            });
        }

        // YouTube Autoplay Logic
        function onPlayerStateChange(event) {
            // YT.PlayerState.ENDED is 0
            if (event.data === 0) { 
                if (document.getElementById('autoplayUnvisitedCheck').checked) {
                    playNextRandomRip();
                }
            }
        }

        function playNextRandomRip() {
            const unvisitedRips = nodes.filter(n => !n.visited && n.type === 'rip');
            if (unvisitedRips.length > 0) {
                const randomIndex = Math.floor(Math.random() * unvisitedRips.length);
                const node = unvisitedRips[randomIndex];
                showPage(node);
                expandNode(node);
            } else {
                console.log("No unvisited rips left. Stopping autoplay.");
                document.getElementById('autoplayUnvisitedCheck').checked = false;
            }
        }



        // --- Init ---
        (function init() {
            initControls();
            // Start with a random rip
            handleRandomNode({});
        })();

    </script>
</body>
</html>